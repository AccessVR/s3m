class t{constructor(t,e={}){this.file=t,this.options=e}async upload(){try{const{key:t,uploadId:e,uuid:a}=await this.startUpload(this.file);if(!e)return void console.error("Upload ID not found");const s=this.options.progress||(()=>{}),o=await this.uploadChunks(this.file,t,e,s),r=await this.completeUpload(t,e,o);return s(100),{uuid:a,key:t,extension:this.file.name.split(".").pop(),name:this.file.name,url:r}}catch(t){console.error(t)}}async startUpload(t){const{name:e,type:a}=t;if(!e)throw new Error("Filename is empty");const{data:s}=await axios.get(route("storage.create.multipart"),{params:{filename:e,content_type:a}});return s}async uploadFilePart(t,e,a,s){const{data:{url:o}}=await axios.get(route("storage.create.sign-part"),{params:{filename:t.name,content_type:t.type,part_number:s,upload_id:a,key:e}});return o}async uploadChunk(t,e,a,s,o,r,n,i){const l=await this.uploadFilePart(t,e,a,s);return{ETag:(await axios.put(l,o,{headers:{"Content-Type":t.type},onUploadProgress:t=>this.handleUploadProgress(t,r,s-1,n,i)})).headers.etag,PartNumber:s}}handleUploadProgress(t,e,a,s,o){const r=Math.round(100*t.loaded/t.total);s[a]=r,o(Math.round(s.reduce((t,e)=>t+e)/e))}async uploadChunks(t,e,a,s){var o=this;const r=ManyRequestsFilesystem.CHUNK_SIZE,n=Math.ceil(t.size/r),i=new Array(n).fill(0),l=[];let u=0,p=0;const c=Array.from({length:ManyRequestsFilesystem.MAX_CONCURRENT_UPLOADS}).map(async function c(){if(p>=n)return;const d=p*r,h=Math.min(d+r,t.size),m=t.slice(d,h);u++,p++;const y=p,U=await o.uploadChunk(t,e,a,y,m,n,i,s);l.push(U),u--,u<ManyRequestsFilesystem.MAX_CONCURRENT_UPLOADS&&c()});for(await Promise.all(c);u>0;)console.log({activeUploads:u}),await new Promise(t=>setTimeout(t,100));return l.sort((t,e)=>t.PartNumber-e.PartNumber)}async completeUpload(t,e,a){const{data:{url:s}}=await axios.post(route("storage.create.multipart-complete"),{parts:a,upload_id:e,key:t});return s}}function e(e,a){return new t(e,a).upload()}t.CHUNK_SIZE=10485760,t.MAX_CONCURRENT_UPLOADS=5;export{e as s3m};
